SHELL32.dll의 첫번째 함수 RAW = 52350 - 1000 + 400 = 51750 -> á.SHGetSpecialFolderPathW.
SHELL32.dll의 두번째 함수 RAW = 5236A - 1000 + 400 = 5176A -> .Ã.SHGetFolderPathW
SHELL32.dll의 세번째 함수 RAW = 5237E - 1000 + 400 = 5177E -> ..ShellAboutW
SHELL32.dll의 네번째 함수 RAW = 5238C - 1000 + 400 = 5178C -> !.ShellExecuteExW.

3) IAT

- 파일에서 IAT 시작 주소는 '0x00000400'이다.
- IAT 크기는 INT와 동일하다.
- 68 04 82 73 -> 0x73820468 -> 'SHGetSpecialFolderPathW' 함수의 주소이다.
- 올리디버거로 해당 주소로 이동하면, 찾을 수 없는 주소이거나, 다른 코드 내용이 출력된다.
- 이유는 PreBinding 기능때문이다.

[참고] PreBinding

- 링킹때 IAT에 실제 Import하는 함수의 주소를 미리 구성하는 기능이다.
- 그렇기 때문에 로딩 시간에 IAT를 완성하지 않고 링키시 IAT를 미리 완성하여 준비하기 때문에 성능이 향상된다.

@ PE 파일 분석(API&DLL)

1. API

 - Application Programming Interface
 - 운영 체제, 프로그램 언어가 응용 프로그램에서 사용할 수 있도록 기능을 제공하는 인터페이스(함수)이다.
 - 윈도우 API 분석은 MSDN 문서를 참조한다.


2. DLL

 - Dynamic Linked Library
 - 여러 프로그램에서 동시에 사용할 수 있는 코드와 데이터를 포함한 라이브러리이다.
 - DLL 이점 : 디스크/메모리에 로딩되는 중복 코드를 최소화, 리소스 사용 최소화, 프로그램 성능 향상


3. Static 링킹 & Dynamic 링킹

 1) Static 링킹

 - 컴파일러 할때 함수가 실행 파일에 연결되는 링킹 방식
 - 실행 파일에 함수의 코드가 복사되기 때문에 파일 크기가 증가된다.
 - 컴파일이 끝나면 라이브러리 파일이 없어도 실행이 가능하다.

 2) Dynamic 링킹

 - 실행할 때 함수가 실행 파일에 연결되는 링킹 방식
 - 실행 파일에 호출할 함수의(주소)정보만 포함되고 실제 함수 코드는 포함되지 않기 때문에 파일 크기가 증가되지 않는다.
 - 그렇기 때문에 실행 파일에서 필요한 라이브러리 파일(DLL 파일)이 꼭 있어야 한다.


4. DLL 로딩 방식

 1) 명시적 링킹

 - 프로그램에서 필요한 시점에 DLL/함수 정보를 로드하고 사용한 이후에 해제하는 방식이다.
 - 다음과 같은 3가지 함수를 이용하여 DLL/함수를 로드하고 해제한다.

 LoadLibrary	필요한 DLL를 프로세스 가상 메모리에 로드하는 함수(DLL를 불러옴)
 GetProcAddress	DLL 함수의 주소 정보를 획득하는 함수(DLL로부터 함수를 불러옴)
 FreeLibrary	프로세스 가상 메모리에 있는 DLL를 해제하는 함수(DLL를 해지함)

 2) 암시적 링킹

 - 실행 파일 자체에서 사용할 DLL/함수 정보를 포함한 이후에 프로그램 실행시 로드하는 방식이다.
 - 즉, 프로그램이 시작되면서 바로 해당 DLL를 로드하는 방식이다.
 - 이때, PE 로더는 PE 파일안에 있는 IAT 정보를 확인하여 DLL 파일을 메모리에 로드한다.



@ 어셈블리(레지스터 이해)

 - 분석 환경 : VMware + Window7(32bit)
 - 사용 도구 : VS 2008, OllyDbg

1. 어셈블리어

 - 기계어가 사용하는 2진수/16진수 숫자들을 사람들이 이해할 수 있도록/제작할 수 있도록 만든 언어이다.
 - C 언어는 몇개 안되는 명령어로 프로그램을 제작할 수 있는 반면에, 어셈블리어는 같은 프로그램을 제작할때 몇 십줄 이상의 코드를 사용해야 한다.


2. 레지스터

 - CPU에 존재하는 저장소이며, 작은 데이터를 임시로 저장하는 용도로 사용한다.
 - 쉽게 이해하려면 레지스터는 변수 개념이다.
 - 다음과 같이 범용 레지스터 8개가 존재한다.

 1) EAX(Extended Accumulator Register)

 - 32bit로 구성
 - 16bit 환경에서는 AX라고 하며, 상위 8bit를 AH, 하위 8bit를 AL라고 한다.
 - 산술 연산 및 논리 연산을 담당한다.
 - 함수의 리턴값이 저장된다. 그렇기 때문에 EAX 값을 확인하여 함수 성공/실패 여부를 확인할 수 있다.

 2) EDX(Extended Data Register)

 - 32bit로 구성
 - 16bit 환경에서는 DX라고 하며, 상위 8bit를 DH, 하위 8bit를 DL라고 한다.
 - 산술 연산을 담당하며, 연산 결과 값이 32bit가 초과되면 EAX 용량이 부족하므로 추가 공간 역할을 담당한다.
 - 나눗셈 경우 몫은 EAX에 저장되고, 나머지는 EDX에 저장된다.
 - 일반 자료를 저장하거나 각종 연산에 필요한 변수 개념으로 사용한다.

 3) ECX(Extended Counter Register)

 - 32bit로 구성
 - 16bit 환경에서는 CX라고 하며, 상위 8bit를 CH, 하위 8bit를 CL라고 한다.
 - 반복문(for, while)을 사용할 경우 반복 카운터로 사용한다.

 4) EBX(Extended Base Register)

 - 32bit로 구성
 - 16bit 환경에서는 BX라고 하며, 상위 8bit를 BH, 하위 8bit를 BL라고 한다.
 - 메모리 주소를 저장하거나, 공간이 필요한 경우 추가적으로 사용하는 여분 레지스터이다.

 5) ESI/EDI(Extended Source Indext)/(Extended Destination Index)

 - 메모리의 한 영역(Source)에서 다른 영역(Destination)으로 데이터를 연속적으로 복사할 때 사용한다.
 - ESI는 데이터를 조작하거나 복사할때 데이터의 출발지 주소가 저장되고, EDI에는 목적지 주소가 저정된다.

 6) ESP(Extended Stack Pointer)

 - 현재 스택 영역에서 가장 낮은 주소를 저장하여 스택의 끝 위치를 알려준다.
 - 변수 선언 및 함수 파라메터 값들이 저장될때 ESP 값은 낮은 주소로 이동된다.

 7) EBP(Extended Base Pointer)

 - 스택에서 함수의 시작 주소 값을 저장한다.
 - 함수 시작시 가장 먼저 스택에 저장된다.

[참고] EIP

 - 다음 실행할 명령어의 주소를 저장한다.
 - EIP 값을 통해서 다음 명령어가 어떤 것인지 알수 있다.


3. 메모리 기본 구조

 - Stack Segment	지역 변수 선언시 할당하는 메모리 영역
 - Data Segment	전역 변수, 정적 변수 선언시 할당하는 메모리 영역
 - Heap Segment	동적 변수 선인시 할당하는 메모리 영역
 - Code Segment 	소스 코드가 저장되어 있는 메모리 영역


4. 스택

 - 스택은 함수 호출시 지역 변수, 함수의 파라메터, 리턴 주소가 저장되는 영역이다.
 - 함수가 호출되면 생성되고 함수 처리가 완료되면 소멸된다.
 - 스택에 값이 저장될때는 높은 주소에서 낮은 주소로 저장되기 때문에 나중에 저장된게 먼저 나가는 구조이다.
 - FILO(First-In Last-Out), LIFO(Last-In First-Out)
 - 그리고 스택에 값이 저장되면 ESP는 현재 위치에서 낮은 주소 위치 값으로 변경되며, EBP는 변경되지 않는다.


5. 스택 프레임

 - 스택 프레임은 함수 프롤로그, 함수 본체, 함수 에필로그 3단계로 구성된다.

 1) 함수 프롤로그

00401020  /$  55            PUSH EBP
00401021  |.  8BEC          MOV EBP,ESP

 2) 함수 본체

00401023  |.  83EC 08       SUB ESP,8
00401026  |.  C745 FC 06000>MOV DWORD PTR SS:[EBP-4],6
0040102D  |.  C745 F8 02000>MOV DWORD PTR SS:[EBP-8],2
00401034  |.  8B45 F8       MOV EAX,DWORD PTR SS:[EBP-8]
00401037  |.  50            PUSH EAX                                 ; /Arg2
00401038  |.  8B4D FC       MOV ECX,DWORD PTR SS:[EBP-4]             ; |
0040103B  |.  51            PUSH ECX                                 ; |Arg1
0040103C  |.  E8 BFFFFFFF   CALL stack.00401000                      ; \stack.00401000
00401041  |.  83C4 08       ADD ESP,8
00401044  |.  50            PUSH EAX
00401045  |.  68 6CA14000   PUSH stack.0040A16C                      ;  ASCII "%d
0040104A  |.  E8 09000000   CALL stack.00401058
0040104F  |.  83C4 08       ADD ESP,8
00401052  |.  33C0          XOR EAX,EAX

 3) 함수 에필로그

00401054  |.  8BE5          MOV ESP,EBP
00401056  |.  5D            POP EBP
00401057  \.  C3            RETN

00401020  /$  55            PUSH EBP
00401021  |.  8BEC          MOV EBP,ESP
